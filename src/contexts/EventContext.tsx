
"use client";

import type { Event, Registration, EventStatus, Feedback } from '@/lib/types';
import React, { createContext, useContext, useState, useEffect, useCallback } from 'react';
import { db } from '@/lib/firebase';
import { 
  collection, 
  doc, 
  getDocs, 
  getDoc, 
  addDoc, 
  updateDoc, 
  deleteDoc, 
  query, 
  where, 
  writeBatch,
  Timestamp
} from 'firebase/firestore';

const initialMockEventsData: Omit<Event, 'id'>[] = [ // Data to seed, ID will be auto-generated by Firestore
  {
    title: 'Summer Music Fest',
    date: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(),
    time: '2:00 PM - 10:00 PM',
    location: 'Central Park Amphitheater',
    description: 'Join us for a day of live music from various artists. Food trucks and fun activities available!',
    category: 'Music',
    maxRegistrants: 500,
    registeredCount: 0, // Will be updated by registrations
    status: 'featured',
    createdBy: 'admin@example.com', // Placeholder, ideally a real user ID
    imageUrl: 'https://placehold.co/600x400.png?text=Summer+Music+Fest',
  },
  {
    title: 'Tech Conference 2024',
    date: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(),
    time: '9:00 AM - 5:00 PM',
    location: 'Grand Convention Hall',
    description: 'Explore the latest trends in technology with keynote speakers and breakout sessions.',
    category: 'Tech',
    maxRegistrants: 200,
    registeredCount: 0,
    status: 'active',
    createdBy: 'admin@example.com',
    imageUrl: 'https://placehold.co/600x400.png?text=Tech+Conference',
  },
    {
    title: 'Local Artisans Workshop',
    date: new Date(Date.now() + 14 * 24 * 60 * 60 * 1000).toISOString(), 
    time: '10:00 AM - 1:00 PM',
    location: 'Community Art Center',
    description: 'Learn pottery and painting from local artisans. Materials provided.',
    category: 'Workshop',
    maxRegistrants: 25,
    registeredCount: 0,
    status: 'active',
    createdBy: 'user@example.com',
    imageUrl: 'https://placehold.co/600x400.png?text=Artisans+Workshop',
  },
  {
    title: 'Cancelled Charity Run',
    date: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000).toISOString(), 
    time: '8:00 AM',
    location: 'City Waterfront',
    description: 'This event was planned to support local charities but has been cancelled due to unforeseen circumstances.',
    category: 'Sports',
    maxRegistrants: 1000,
    registeredCount: 0,
    status: 'cancelled',
    createdBy: 'admin@example.com',
    imageUrl: 'https://placehold.co/600x400.png?text=Charity+Run+Cancelled',
  },
  {
    title: 'Past Gourmet Food Fair',
    date: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString(), 
    time: '11:00 AM - 6:00 PM',
    location: 'Downtown Plaza',
    description: 'A delightful fair featuring local and international cuisines. This event has concluded.',
    category: 'Food & Drink',
    maxRegistrants: 300,
    registeredCount: 285, 
    status: 'past',
    createdBy: 'admin@example.com',
    imageUrl: 'https://placehold.co/600x400.png?text=Gourmet+Food+Fair',
  },
];


interface EventContextType {
  events: Event[];
  isLoading: boolean;
  addEvent: (eventData: Omit<Event, 'id' | 'registeredCount' | 'createdBy' | 'status'>, userId: string) => Promise<Event>;
  updateEvent: (eventData: Event) => Promise<Event>;
  deleteEvent: (eventId: string) => Promise<void>;
  getEventById: (eventId: string) => Event | undefined; 
  fetchEventById: (eventId: string) => Promise<Event | undefined>; 
  registerForEvent: (eventId: string, userId: string) => Promise<boolean>;
  getRegistrationsForUser: (userId: string) => Promise<Registration[]>;
  isUserRegistered: (eventId: string, userId: string) => Promise<boolean>;
  getEventsCreatedByUser: (userId: string) => Promise<Event[]>;
  refreshEvents: () => Promise<void>;
  submitFeedback: (feedbackData: Omit<Feedback, 'id' | 'submittedAt'>) => Promise<Feedback>;
  getFeedbackForEvent: (eventId: string) => Promise<Feedback[]>;
  hasUserSubmittedFeedback: (eventId: string, userId: string) => Promise<boolean>;
}

const EventContext = createContext<EventContextType | undefined>(undefined);

export const EventProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [events, setEvents] = useState<Event[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  const seedInitialEvents = async () => {
    const eventsCollectionRef = collection(db, "events");
    const batch = writeBatch(db);
    initialMockEventsData.forEach(eventData => {
      const newEventRef = doc(eventsCollectionRef); 
      const eventWithTimestamp = {
        ...eventData,
        date: Timestamp.fromDate(new Date(eventData.date)), 
      };
      batch.set(newEventRef, eventWithTimestamp);
    });
    await batch.commit();
    console.log("Initial events seeded to Firestore.");
  };

  const fetchEventsFromFirestore = useCallback(async () => {
    setIsLoading(true);
    try {
      const eventsCollectionRef = collection(db, "events");
      const querySnapshot = await getDocs(eventsCollectionRef);
      let fetchedEventsFromDB: Event[] = [];

      if (querySnapshot.empty && initialMockEventsData.length > 0) {
        await seedInitialEvents();
        const seededSnapshot = await getDocs(eventsCollectionRef);
        fetchedEventsFromDB = seededSnapshot.docs.map(docSnap => {
          const data = docSnap.data();
          return {
            ...data,
            id: docSnap.id,
            date: (data.date as Timestamp).toDate().toISOString(),
          } as Event;
        });
      } else {
        fetchedEventsFromDB = querySnapshot.docs.map(docSnap => {
          const data = docSnap.data();
          return {
            ...data,
            id: docSnap.id,
            date: (data.date as Timestamp).toDate().toISOString(),
          } as Event;
        });
      }

      const today = new Date();
      today.setHours(0, 0, 0, 0); 

      const updateBatch = writeBatch(db);
      let eventsToUpdateInFirestore = false;

      const processedEvents = fetchedEventsFromDB.map(event => {
        const eventDate = new Date(event.date);
        if (eventDate < today && (event.status === 'active' || event.status === 'featured')) {
          const eventRef = doc(db, "events", event.id);
          updateBatch.update(eventRef, { status: 'past' });
          eventsToUpdateInFirestore = true;
          return { ...event, status: 'past' as EventStatus }; 
        }
        return event;
      });

      if (eventsToUpdateInFirestore) {
        await updateBatch.commit();
        console.log("Updated status for past events in Firestore.");
        setEvents(processedEvents); 
      } else {
        setEvents(fetchedEventsFromDB); 
      }
    } catch (error) {
      console.error("Failed to load events from Firestore or update past events:", error);
      setEvents([]); 
    }
    setIsLoading(false);
  }, []);

  useEffect(() => {
    fetchEventsFromFirestore();
  }, [fetchEventsFromFirestore]);

  const addEvent = useCallback(async (eventData: Omit<Event, 'id' | 'registeredCount' | 'createdBy' | 'status'>, userId: string): Promise<Event> => {
    setIsLoading(true);
    const newEventData = {
      ...eventData,
      date: Timestamp.fromDate(new Date(eventData.date)), 
      registeredCount: 0,
      createdBy: userId,
      status: 'active' as Event['status'], 
    };
    try {
      const docRef = await addDoc(collection(db, "events"), newEventData);
      const createdEvent: Event = { 
        ...eventData, 
        id: docRef.id, 
        registeredCount: 0, 
        createdBy: userId, 
        status: 'active' 
      };
      await fetchEventsFromFirestore(); 
      setIsLoading(false);
      return createdEvent; 
    } catch (error) {
      console.error("Error adding event to Firestore:", error);
      setIsLoading(false);
      throw error;
    }
  }, [fetchEventsFromFirestore]);

  const updateEvent = useCallback(async (eventData: Event): Promise<Event> => {
    setIsLoading(true);
    const eventRef = doc(db, "events", eventData.id);
    const dataToUpdate = {
      ...eventData,
      date: Timestamp.fromDate(new Date(eventData.date)), 
    };
    delete (dataToUpdate as any).id; 

    try {
      await updateDoc(eventRef, dataToUpdate);
      await fetchEventsFromFirestore();
      setIsLoading(false);
      return eventData; 
    } catch (error) {
      console.error("Error updating event in Firestore:", error);
      setIsLoading(false);
      throw error;
    }
  }, [fetchEventsFromFirestore]);

  const deleteEvent = useCallback(async (eventId: string): Promise<void> => {
    setIsLoading(true);
    const eventRef = doc(db, "events", eventId);
    try {
      await deleteDoc(eventRef);
      const registrationsQuery = query(collection(db, "registrations"), where("eventId", "==", eventId));
      const registrationSnapshot = await getDocs(registrationsQuery);
      const feedbackQuery = query(collection(db, "feedback"), where("eventId", "==", eventId));
      const feedbackSnapshot = await getDocs(feedbackQuery);

      const batch = writeBatch(db);
      registrationSnapshot.docs.forEach(docSnap => batch.delete(docSnap.ref));
      feedbackSnapshot.docs.forEach(docSnap => batch.delete(docSnap.ref));
      await batch.commit();

      setEvents(prev => prev.filter(e => e.id !== eventId)); 
      setIsLoading(false);
    } catch (error) {
      console.error("Error deleting event and related data from Firestore:", error);
      await fetchEventsFromFirestore(); 
      setIsLoading(false);
      throw error;
    }
  }, [fetchEventsFromFirestore]);
  
  const getEventById = useCallback((eventId: string) => {
    return events.find(e => e.id === eventId); 
  }, [events]);

  const fetchEventById = useCallback(async (eventId: string): Promise<Event | undefined> => {
    setIsLoading(true);
    try {
      const eventRef = doc(db, "events", eventId);
      const docSnap = await getDoc(eventRef);
      setIsLoading(false);
      if (docSnap.exists()) {
        const data = docSnap.data();
        let event = { 
            ...data, 
            id: docSnap.id,
            date: (data.date as Timestamp).toDate().toISOString(),
         } as Event;

        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const eventDate = new Date(event.date);
        if(eventDate < today && (event.status === 'active' || event.status === 'featured')) {
            await updateDoc(eventRef, { status: 'past' });
            event.status = 'past';
        }
        return event;
      }
      return undefined;
    } catch (error) {
      console.error("Error fetching event by ID:", error);
      setIsLoading(false);
      return undefined;
    }
  }, []);


  const getRegistrationsForUser = useCallback(async (userId: string): Promise<Registration[]> => {
    try {
      const q = query(collection(db, "registrations"), where("userId", "==", userId));
      const querySnapshot = await getDocs(q);
      return querySnapshot.docs.map(docSnap => {
        const data = docSnap.data();
        return {
            ...data,
            id: docSnap.id, 
            registrationDate: (data.registrationDate as Timestamp).toDate().toISOString(),
        } as Registration;
      });
    } catch (error) {
      console.error("Failed to load registrations from Firestore:", error);
      return [];
    }
  }, []);

  const isUserRegistered = useCallback(async (eventId: string, userId: string): Promise<boolean> => {
    try {
      const q = query(collection(db, "registrations"), where("userId", "==", userId), where("eventId", "==", eventId));
      const querySnapshot = await getDocs(q);
      return !querySnapshot.empty;
    } catch (error) {
      console.error("Error checking registration:", error);
      return false;
    }
  }, []);

  const registerForEvent = useCallback(async (eventId: string, userId: string): Promise<boolean> => {
    const eventDetails = await fetchEventById(eventId); 
    if (!eventDetails) return false; 
    
    if (eventDetails.status !== 'active' && eventDetails.status !== 'featured') {
        console.log(`Registration failed: Event status is ${eventDetails.status}`);
        return false;
    }

    if (await isUserRegistered(eventId, userId)) return true; 

    if (eventDetails.maxRegistrants && eventDetails.registeredCount >= eventDetails.maxRegistrants) {
      console.log("Registration failed: Event is full.");
      return false; 
    }

    const newRegistrationData = { 
      userId, 
      eventId, 
      registrationDate: Timestamp.now() 
    };
    
    try {
      await addDoc(collection(db, "registrations"), newRegistrationData);
      const eventRef = doc(db, "events", eventId);
      await updateDoc(eventRef, {
        registeredCount: eventDetails.registeredCount + 1
      });
      await fetchEventsFromFirestore(); 
      return true;
    } catch (error) {
      console.error("Failed to save registration to Firestore:", error);
      return false;
    }
  }, [fetchEventById, isUserRegistered, fetchEventsFromFirestore]);

  const getEventsCreatedByUser = useCallback(async (userId: string): Promise<Event[]> => {
    setIsLoading(true);
    try {
      const userCreatedEvents = events.filter(event => event.createdBy === userId);
      
      if (events.length === 0 && !isLoading) { 
         const eventsQuery = query(collection(db, "events"), where("createdBy", "==", userId));
         const querySnapshot = await getDocs(eventsQuery);
         const fetchedEvents = querySnapshot.docs.map(docSnap => {
            const data = docSnap.data();
            return {
                ...data,
                id: docSnap.id,
                date: (data.date as Timestamp).toDate().toISOString(),
            } as Event;
         });
         setIsLoading(false);
         return fetchedEvents.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
      }

      setIsLoading(false);
      return userCreatedEvents.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
    } catch (error) {
      console.error("Failed to load events created by user:", error);
      setIsLoading(false);
      return [];
    }
  }, [events, isLoading]);

  const submitFeedback = useCallback(async (feedbackData: Omit<Feedback, 'id' | 'submittedAt'>): Promise<Feedback> => {
    setIsLoading(true);
    const newFeedbackData = {
      ...feedbackData,
      submittedAt: Timestamp.now(),
    };
    try {
      const docRef = await addDoc(collection(db, "feedback"), newFeedbackData);
      const createdFeedback: Feedback = {
        ...feedbackData,
        id: docRef.id,
        submittedAt: (newFeedbackData.submittedAt as Timestamp).toDate().toISOString(),
      };
      // No need to update local events state directly, feedback is separate
      setIsLoading(false);
      return createdFeedback;
    } catch (error) {
      console.error("Error submitting feedback to Firestore:", error);
      setIsLoading(false);
      throw error;
    }
  }, []);

  const getFeedbackForEvent = useCallback(async (eventId: string): Promise<Feedback[]> => {
    // This might load many feedbacks, consider pagination for a real app if feedback volume is high
    try {
      const q = query(collection(db, "feedback"), where("eventId", "==", eventId));
      const querySnapshot = await getDocs(q);
      return querySnapshot.docs.map(docSnap => {
        const data = docSnap.data();
        return {
          ...data,
          id: docSnap.id,
          submittedAt: (data.submittedAt as Timestamp).toDate().toISOString(),
        } as Feedback;
      }).sort((a,b) => new Date(b.submittedAt).getTime() - new Date(a.submittedAt).getTime());
    } catch (error) {
      console.error("Failed to load feedback from Firestore:", error);
      return [];
    }
  }, []);

  const hasUserSubmittedFeedback = useCallback(async (eventId: string, userId: string): Promise<boolean> => {
    if (!userId || !eventId) return false;
    try {
      const q = query(collection(db, "feedback"), where("eventId", "==", eventId), where("userId", "==", userId));
      const querySnapshot = await getDocs(q);
      return !querySnapshot.empty;
    } catch (error) {
      console.error("Error checking if user submitted feedback:", error);
      return false; 
    }
  }, []);


  return (
    <EventContext.Provider value={{ 
      events, 
      isLoading, 
      addEvent, 
      updateEvent, 
      deleteEvent,
      getEventById,
      fetchEventById,
      registerForEvent,
      getRegistrationsForUser,
      isUserRegistered,
      getEventsCreatedByUser,
      refreshEvents: fetchEventsFromFirestore,
      submitFeedback,
      getFeedbackForEvent,
      hasUserSubmittedFeedback,
    }}>
      {children}
    </EventContext.Provider>
  );
};

export const useEvents = () => {
  const context = useContext(EventContext);
  if (context === undefined) {
    throw new Error('useEvents must be used within an EventProvider');
  }
  return context;
};
